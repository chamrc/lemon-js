import { Schema, SchemaTypeOpts } from 'mongoose';
import 'reflect-metadata';
import { TypedModel } from '../model';

export interface SchemaTypeOptions<T> extends SchemaTypeOpts<T> {
	// From lemon-js
	refer?: Constructor;
	ref?: Constructor;
}

export type Constructor = {
	new(...args): any
};

export type PropertyMetaType<T> = SchemaTypeOptions<T>
	| [any]
	| boolean
	| Boolean
	| Buffer
	| Date
	| number
	| Number
	| string
	| String
	| Schema.Types.Array
	| Schema.Types.Boolean
	| Schema.Types.Buffer
	| Schema.Types.Date
	| Schema.Types.Decimal128
	| Schema.Types.DocumentArray
	| Schema.Types.Embedded
	| Schema.Types.Mixed
	| Schema.Types.Number
	| Schema.Types.ObjectId
	| Schema.Types.String
	| any;

export function property<T>(target: TypedModel, propertyKey: string): void;
export function property<T>(
	meta: SchemaTypeOptions<T>
): (target: TypedModel, propertyKey: string) => void;
export function property<T>(
	targetOrMeta: TypedModel | SchemaTypeOptions<T>,
	propertyKey?: string,
) {
	if (targetOrMeta instanceof TypedModel) {
		savePropertyMeta(targetOrMeta, propertyKey);
		return;
	}

	const meta = targetOrMeta;
	return (target: TypedModel, propKey: string) => {
		savePropertyMeta(target, propKey, meta);
	};
}

function savePropertyMeta(target: TypedModel, propertyKey: string, meta: any = {}) {
	const constructor = (target.constructor as any);
	if (!constructor._meta) {
		constructor._meta = {
			properties: {},
			schemaOptions: {}
		};
	}

	const propsMeta: object = constructor._meta.properties;

	// Wrap validators with the object.
	if (meta.validate) {
		let newValidate;

		if (Array.isArray(meta.validate)) {
			if (meta.validate.length === 2 &&
				typeof meta.validate[0] === 'function' &&
				typeof meta.validate[1] === 'string') {
				// var custom = [validator, 'Uh oh, {PATH} does not equal "something".']
				// new Schema({ name: { type: String, validate: custom } });
				newValidate = {
					validator: wrapValidator(meta.validate[0]),
					message: meta.validate[1]
				};
			} else {
				// let many = [
				// 	{ validator: validator, message: 'uh oh' },
				// 	{ validator: anotherValidator, message: 'failed' }
				// ];
				// new Schema({ name: { type: String, validate: many } });
				newValidate = meta.validate.map((x) => {
					return {
						validator: wrapValidator(x.validator),
						message: x.msg ? x.msg : x.message
					};
				});
			}
		} else if (typeof meta.validate === 'function') {
			// new Schema({ name: { type: String, validate: function validator(val) {} } });
			newValidate = wrapValidator(meta.validate);
		} else {
			// new Schema({ name: { type: String, validate: {
			// 	isAsync: true,
			// 	validator: function validator(val) {}
			// }}});
			const isAsync = meta.validate.isAsync;
			newValidate = {
				isAsync,
				validator: wrapValidator(meta.validate.validator, isAsync),
				message: meta.validate.message
			};
		}

		meta.validate = newValidate;
	}

	// Set type according to metadata generated by typescript
	if (!meta.type) {
		const type = Reflect.getMetadata('design:type', target, propertyKey);

		if (type) {
			meta.type = type;
		} else {
			const name = constructor.name;
			throw new Error(
				`Type of ${ name }.${ propertyKey } isn't set. Uf you use typescript ` +
				'you need to enable emitDecoratorMetadata in tsconfig.json',
			);
		}

		propsMeta[propertyKey] = meta;
	}
}

function wrapValidator(validator, isAsync = false) {
	if (isAsync) {
		return function (value, callback) {
			// Validator format:
			validator(value, this, callback);
		};
	} else {
		return function (value) {
			return validator(value, this);
		};
	}
}
